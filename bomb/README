This is an x86-64 bomb for self-study students.

这个实验比较有趣，也比较知名。不妨自己尝试一下。

Solution:

`bomb.c` 是无法编译运行的，可以看出程序有 6 个阶段，每个阶段输入一个字符串，可以从文件读取。
直接在容器下运行 `./bomb`，可以看到欢迎界面，随便输入一个字符串，则会触发炸弹。

第一步用 `objdump` 反编译

`objdump -d bomb > bomb.asm` 找到  phase_1 可以发现这儿调用了 strings_not_equal 函数，`%rdi` 存放了 input 字符串
 在调用函数之前执行了 `movl	$4203520, %esi`， 大概可以猜出是与 `$4203520` 字符串比较。这个地址是变化的，在容器下可能不一样。
 比较简单的方式就是直接用 gdb 找到这个字符串
 ```
 > gdb bomb
 > c     // continue
 > break phase_1
 > stepi // 单步到代码附近
 > layout asm // 也可以直接查看目标地址
 > print (char *) 目标地址
 ```


紧跟着的几个都是考察汇编了，很多指令都忘记了，不过还好二三比较简单，第四个看吐了直接找了答案。
第五个有点意思，不过逻辑并不复杂。提示：将你输入的字符串加密与目标字符串比较，你需要找到字典和密令。

最后一个考察逻辑的，一点一点翻译吧。仔细一点，要不然看着排序完成，顺序反了，浪费半天排查。
输入 6 个数字，每个数字不能超过 6，然后每个数字会对应到一个节点上，最后检查这个链表顺序是否是降序的。
